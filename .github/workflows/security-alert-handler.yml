name: Security Alert Handler

on:
  security_advisory:
    types: [published, updated]
  
  workflow_run:
    workflows: ["CodeQL Analysis", "Dependency Review"]
    types: [completed]
  
  schedule:
    # Run security checks daily at 2 AM JST (5 PM UTC)
    - cron: '0 17 * * *'
  
  workflow_dispatch:
    inputs:
      alert_type:
        description: 'Type of security alert to process'
        required: true
        type: choice
        options:
          - vulnerability_scan
          - dependency_check
          - secret_scan
          - code_analysis
          - all

jobs:
  process_security_alerts:
    name: Process Security Alerts
    runs-on: ubuntu-latest
    permissions:
      security-events: write
      contents: read
      issues: write
      pull-requests: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Install dependencies
        run: |
          pip install requests pyyaml semver
      
      - name: Fetch Dependabot alerts
        id: dependabot
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Fetching Dependabot alerts..."
          
          # Get Dependabot alerts
          ALERTS=$(gh api \
            -H "Accept: application/vnd.github+json" \
            /repos/${{ github.repository }}/dependabot/alerts \
            --paginate) || echo "[]"
          
          # Count critical and high severity alerts
          CRITICAL_COUNT=$(echo "$ALERTS" | jq '[.[] | select(.security_advisory.severity == "critical")] | length')
          HIGH_COUNT=$(echo "$ALERTS" | jq '[.[] | select(.security_advisory.severity == "high")] | length')
          
          echo "critical_count=${CRITICAL_COUNT}" >> $GITHUB_OUTPUT
          echo "high_count=${HIGH_COUNT}" >> $GITHUB_OUTPUT
          
          # Save alerts for processing
          echo "$ALERTS" > dependabot_alerts.json
      
      - name: Fetch code scanning alerts
        id: code_scanning
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Fetching code scanning alerts..."
          
          # Get code scanning alerts
          ALERTS=$(gh api \
            -H "Accept: application/vnd.github+json" \
            /repos/${{ github.repository }}/code-scanning/alerts \
            --paginate) || echo "[]"
          
          # Count by severity
          ERROR_COUNT=$(echo "$ALERTS" | jq '[.[] | select(.rule.severity == "error")] | length')
          WARNING_COUNT=$(echo "$ALERTS" | jq '[.[] | select(.rule.severity == "warning")] | length')
          
          echo "error_count=${ERROR_COUNT}" >> $GITHUB_OUTPUT
          echo "warning_count=${WARNING_COUNT}" >> $GITHUB_OUTPUT
          
          # Save alerts for processing
          echo "$ALERTS" > code_scanning_alerts.json
      
      - name: Fetch secret scanning alerts
        id: secret_scanning
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Fetching secret scanning alerts..."
          
          # Get secret scanning alerts
          ALERTS=$(gh api \
            -H "Accept: application/vnd.github+json" \
            /repos/${{ github.repository }}/secret-scanning/alerts \
            --paginate) || echo "[]"
          
          # Count open alerts
          OPEN_COUNT=$(echo "$ALERTS" | jq '[.[] | select(.state == "open")] | length')
          
          echo "open_secrets=${OPEN_COUNT}" >> $GITHUB_OUTPUT
          
          # Save alerts for processing
          echo "$ALERTS" > secret_scanning_alerts.json
      
      - name: Analyze and prioritize alerts
        id: analyze
        run: |
          cat > analyze_alerts.py << 'EOF'
          import json
          import sys
          from datetime import datetime, timedelta
          
          # Load all alerts
          with open('dependabot_alerts.json', 'r') as f:
              dependabot = json.load(f) if f else []
          
          with open('code_scanning_alerts.json', 'r') as f:
              code_scanning = json.load(f) if f else []
          
          with open('secret_scanning_alerts.json', 'r') as f:
              secret_scanning = json.load(f) if f else []
          
          # Prioritization logic
          priority_alerts = {
              'P0': [],
              'P1': [],
              'P2': [],
              'P3': []
          }
          
          # Process Dependabot alerts
          for alert in dependabot:
              severity = alert.get('security_advisory', {}).get('severity', 'low')
              cvss = alert.get('security_advisory', {}).get('cvss', {}).get('score', 0)
              
              if severity == 'critical' or cvss >= 9.0:
                  priority_alerts['P0'].append({
                      'type': 'dependency',
                      'package': alert.get('dependency', {}).get('package', {}).get('name'),
                      'severity': severity,
                      'cvss': cvss,
                      'description': alert.get('security_advisory', {}).get('summary')
                  })
              elif severity == 'high' or cvss >= 7.0:
                  priority_alerts['P1'].append({
                      'type': 'dependency',
                      'package': alert.get('dependency', {}).get('package', {}).get('name'),
                      'severity': severity,
                      'cvss': cvss
                  })
          
          # Process code scanning alerts
          for alert in code_scanning:
              severity = alert.get('rule', {}).get('severity', 'note')
              
              if severity == 'error':
                  priority = 'P1' if 'security' in alert.get('rule', {}).get('tags', []) else 'P2'
                  priority_alerts[priority].append({
                      'type': 'code_scanning',
                      'rule': alert.get('rule', {}).get('id'),
                      'severity': severity,
                      'location': f"{alert.get('location', {}).get('path')}:{alert.get('location', {}).get('start_line')}"
                  })
          
          # Process secret scanning alerts
          for alert in secret_scanning:
              if alert.get('state') == 'open':
                  priority_alerts['P0'].append({
                      'type': 'secret',
                      'secret_type': alert.get('secret_type'),
                      'locations': len(alert.get('locations', []))
                  })
          
          # Generate summary
          summary = {
              'timestamp': datetime.now().isoformat(),
              'total_alerts': len(dependabot) + len(code_scanning) + len(secret_scanning),
              'priority_breakdown': {
                  'P0': len(priority_alerts['P0']),
                  'P1': len(priority_alerts['P1']),
                  'P2': len(priority_alerts['P2']),
                  'P3': len(priority_alerts['P3'])
              },
              'alerts': priority_alerts
          }
          
          # Output for GitHub Actions
          print(f"::set-output name=p0_count::{len(priority_alerts['P0'])}")
          print(f"::set-output name=p1_count::{len(priority_alerts['P1'])}")
          print(f"::set-output name=total_critical::{len(priority_alerts['P0']) + len(priority_alerts['P1'])}")
          
          # Save analysis
          with open('alert_analysis.json', 'w') as f:
              json.dump(summary, f, indent=2)
          
          # Determine if incident response is needed
          if len(priority_alerts['P0']) > 0:
              print("::set-output name=trigger_incident::true")
              print("::set-output name=incident_severity::P0")
          elif len(priority_alerts['P1']) > 2:
              print("::set-output name=trigger_incident::true")
              print("::set-output name=incident_severity::P1")
          else:
              print("::set-output name=trigger_incident::false")
          EOF
          
          python analyze_alerts.py
      
      - name: Create security issues
        if: steps.analyze.outputs.p0_count > 0 || steps.analyze.outputs.p1_count > 0
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Read alert analysis
          ANALYSIS=$(cat alert_analysis.json)
          
          # Create issue for P0 alerts
          if [ "${{ steps.analyze.outputs.p0_count }}" -gt "0" ]; then
            gh issue create \
              --title "üö® Critical Security Alerts Detected" \
              --label "security,priority:critical" \
              --body "## Critical Security Alerts
          
          **Detection Time**: $(date -Iseconds)
          **P0 Alerts**: ${{ steps.analyze.outputs.p0_count }}
          
          ### Immediate Actions Required:
          1. Review secret scanning alerts
          2. Revoke exposed credentials
          3. Patch critical vulnerabilities
          
          ### Alert Summary:
          \`\`\`json
          $(echo "$ANALYSIS" | jq '.alerts.P0')
          \`\`\`
          
          **Workflow Run**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          fi
      
      - name: Auto-remediation for dependencies
        if: steps.dependabot.outputs.critical_count > 0 || steps.dependabot.outputs.high_count > 0
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Attempting auto-remediation for dependency vulnerabilities..."
          
          # Create fix branch
          BRANCH_NAME="security/auto-fix-$(date +%Y%m%d-%H%M%S)"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git checkout -b ${BRANCH_NAME}
          
          # Apply Dependabot security updates if available
          gh api \
            -H "Accept: application/vnd.github+json" \
            /repos/${{ github.repository }}/dependabot/alerts \
            --jq '.[] | select(.security_advisory.severity == "critical" or .security_advisory.severity == "high") | .number' | \
          while read alert_number; do
            echo "Processing alert #${alert_number}"
            # In production, this would apply the security update
          done
          
          # Check if changes were made
          if git diff --quiet; then
            echo "No automatic fixes available"
          else
            git add .
            git commit -m "fix(security): Auto-remediate critical vulnerabilities
          
          - Applied Dependabot security updates
          - Fixed critical and high severity issues
          
          Auto-generated by GitHub Actions"
            
            git push origin ${BRANCH_NAME}
            
            # Create PR
            gh pr create \
              --title "üîí Auto-fix: Critical Security Vulnerabilities" \
              --body "## Automated Security Fix
          
          This PR was automatically generated to fix critical security vulnerabilities.
          
          ### Vulnerabilities Fixed:
          - Critical: ${{ steps.dependabot.outputs.critical_count }}
          - High: ${{ steps.dependabot.outputs.high_count }}
          
          ### Actions Taken:
          - Applied Dependabot security updates
          - Updated vulnerable dependencies
          
          ‚ö†Ô∏è **Please review changes carefully before merging.**" \
              --label "security,automated" \
              --base main
          fi
      
      - name: Trigger incident response
        if: steps.analyze.outputs.trigger_incident == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Generate incident ID
          INCIDENT_ID="INC-$(date +%Y%m%d-%H%M%S)"
          
          # Trigger incident response workflow
          gh workflow run incident-response.yml \
            -f incident_id="${INCIDENT_ID}" \
            -f severity="${{ steps.analyze.outputs.incident_severity }}" \
            -f incident_type="vulnerability"
          
          echo "Incident response triggered: ${INCIDENT_ID}"
      
      - name: Generate security report
        run: |
          cat > security_report.md << EOF
          # Security Alert Report
          
          **Generated**: $(date -Iseconds)
          **Repository**: ${{ github.repository }}
          
          ## Summary
          
          | Alert Type | Critical | High | Medium | Low |
          |------------|----------|------|--------|-----|
          | Dependencies | ${{ steps.dependabot.outputs.critical_count }} | ${{ steps.dependabot.outputs.high_count }} | - | - |
          | Code Scanning | ${{ steps.code_scanning.outputs.error_count }} | ${{ steps.code_scanning.outputs.warning_count }} | - | - |
          | Secrets | ${{ steps.secret_scanning.outputs.open_secrets }} | - | - | - |
          
          ## Priority Actions
          
          $(if [ "${{ steps.analyze.outputs.p0_count }}" -gt "0" ]; then
            echo "### üö® P0 - Critical (Immediate Action Required)"
            echo "- Review and remediate all P0 alerts immediately"
            echo "- Incident response has been triggered"
          fi)
          
          $(if [ "${{ steps.analyze.outputs.p1_count }}" -gt "0" ]; then
            echo "### ‚ö†Ô∏è P1 - High (Action Required Within 24 Hours)"
            echo "- Review and plan remediation for P1 alerts"
            echo "- Schedule fixes for next release"
          fi)
          
          ## Automated Actions Taken
          
          - Security alerts analyzed and prioritized
          - Issues created for critical findings
          - Auto-remediation attempted where possible
          $(if [ "${{ steps.analyze.outputs.trigger_incident }}" == "true" ]; then
            echo "- Incident response workflow triggered"
          fi)
          
          ## Next Steps
          
          1. Review created issues and PRs
          2. Validate auto-remediation changes
          3. Update security policies as needed
          4. Schedule security review meeting
          
          ---
          
          *This report was automatically generated by the Security Alert Handler workflow.*
          EOF
          
          cat security_report.md
      
      - name: Upload security artifacts
        uses: actions/upload-artifact@v3
        with:
          name: security-alerts-$(date +%Y%m%d-%H%M%S)
          path: |
            *_alerts.json
            alert_analysis.json
            security_report.md
          retention-days: 30
      
      - name: Send notifications
        if: steps.analyze.outputs.total_critical > 0
        env:
          TEAMS_WEBHOOK: ${{ secrets.TEAMS_WEBHOOK_URL }}
        run: |
          MESSAGE=$(cat << EOF
          {
            "@type": "MessageCard",
            "@context": "https://schema.org/extensions",
            "summary": "Security Alerts Detected",
            "themeColor": "${{ steps.analyze.outputs.p0_count > 0 && 'FF0000' || 'FF8800' }}",
            "title": "‚ö†Ô∏è Security Alert Summary",
            "sections": [{
              "facts": [
                {"name": "P0 Alerts", "value": "${{ steps.analyze.outputs.p0_count }}"},
                {"name": "P1 Alerts", "value": "${{ steps.analyze.outputs.p1_count }}"},
                {"name": "Total Critical", "value": "${{ steps.analyze.outputs.total_critical }}"},
                {"name": "Repository", "value": "${{ github.repository }}"}
              ]
            }],
            "potentialAction": [{
              "@type": "OpenUri",
              "name": "View Details",
              "targets": [{
                "os": "default",
                "uri": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
              }]
            }]
          }
          EOF
          )
          
          if [ ! -z "${TEAMS_WEBHOOK}" ]; then
            curl -H "Content-Type: application/json" -d "${MESSAGE}" "${TEAMS_WEBHOOK}"
          fi