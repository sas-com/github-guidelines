name: DAST Security Testing

on:
  schedule:
    - cron: '0 3 * * *'  # æ¯Žæ—¥ 3:00 JST
  workflow_dispatch:
    inputs:
      target_environment:
        description: 'Target environment for DAST scan'
        required: true
        default: 'staging'
        type: choice
        options:
          - development
          - staging
          - production

env:
  SCAN_RESULTS_PATH: dast-results
  NOTIFICATION_ENABLED: true

permissions:
  contents: read
  security-events: write
  issues: write
  pull-requests: write

jobs:
  # ===== Environment Setup =====
  setup-environment:
    name: Setup Test Environment
    runs-on: ubuntu-latest
    outputs:
      target_url: ${{ steps.get-url.outputs.url }}
      
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Determine Target URL
      id: get-url
      run: |
        if [ "${{ github.event.inputs.target_environment || 'staging' }}" == "production" ]; then
          echo "url=https://api.sas-com.com" >> $GITHUB_OUTPUT
        elif [ "${{ github.event.inputs.target_environment || 'staging' }}" == "staging" ]; then
          echo "url=https://staging-api.sas-com.com" >> $GITHUB_OUTPUT
        else
          echo "url=http://localhost:8080" >> $GITHUB_OUTPUT
        fi
        
    - name: Deploy Test Environment (if local)
      if: contains(steps.get-url.outputs.url, 'localhost')
      run: |
        # Deploy test environment using Docker Compose
        docker-compose -f docker-compose.test.yml up -d
        
        # Wait for services to be ready
        echo "Waiting for services to start..."
        sleep 30
        
        # Health check
        for i in {1..10}; do
          if curl -f http://localhost:8080/health; then
            echo "Service is ready"
            break
          fi
          echo "Waiting for service... (attempt $i/10)"
          sleep 10
        done

  # ===== OWASP ZAP Scanning =====
  owasp-zap-scan:
    name: OWASP ZAP Security Scan
    runs-on: ubuntu-latest
    needs: setup-environment
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Create ZAP Configuration
      run: |
        mkdir -p .zap
        cat > .zap/rules.tsv << 'EOF'
        10015	IGNORE	(Incomplete or No Cache-control and Pragma HTTP Header Set)
        10027	IGNORE	(Information Disclosure - Suspicious Comments)
        10096	IGNORE	(Timestamp Disclosure - Unix)
        10055	IGNORE	(CSP: Wildcard Directive)
        EOF
        
        cat > .zap/context.json << 'EOF'
        {
          "name": "SAS API Context",
          "urls": ["${{ needs.setup-environment.outputs.target_url }}"],
          "authentication": {
            "method": "jwt",
            "parameters": {
              "loginUrl": "${{ needs.setup-environment.outputs.target_url }}/auth/login",
              "username": "${{ secrets.TEST_USERNAME }}",
              "password": "${{ secrets.TEST_PASSWORD }}"
            }
          },
          "users": [{
            "name": "test-user",
            "credentials": {
              "username": "${{ secrets.TEST_USERNAME }}",
              "password": "${{ secrets.TEST_PASSWORD }}"
            }
          }]
        }
        EOF
        
    - name: ZAP Baseline Scan
      uses: zaproxy/action-baseline@v0.10.0
      with:
        target: ${{ needs.setup-environment.outputs.target_url }}
        rules_file_name: '.zap/rules.tsv'
        cmd_options: '-a -j -l WARN --auto'
        allow_issue_writing: false
        
    - name: ZAP Full Scan
      if: github.event.inputs.target_environment != 'production'
      uses: zaproxy/action-full-scan@v0.10.0
      with:
        target: ${{ needs.setup-environment.outputs.target_url }}
        rules_file_name: '.zap/rules.tsv'
        cmd_options: '-a -j --auto'
        allow_issue_writing: false
        
    - name: ZAP API Scan
      if: fileExists('openapi.yml') || fileExists('swagger.json')
      uses: zaproxy/action-api-scan@v0.10.0
      with:
        target: ${{ needs.setup-environment.outputs.target_url }}/openapi.json
        format: 'openapi'
        rules_file_name: '.zap/rules.tsv'
        cmd_options: '-a -j'
        
    - name: Upload ZAP Reports
      uses: actions/upload-artifact@v4
      with:
        name: zap-scan-results
        path: |
          zap_baseline_report.html
          zap_full_report.html
          zap_api_report.html
        retention-days: 30

  # ===== Nuclei Security Scanning =====
  nuclei-scan:
    name: Nuclei Security Templates
    runs-on: ubuntu-latest
    needs: setup-environment
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Create Custom Nuclei Templates
      run: |
        mkdir -p .nuclei/custom-templates
        
        # SQL Injection template
        cat > .nuclei/custom-templates/sqli-test.yaml << 'EOF'
        id: sql-injection-test
        info:
          name: SQL Injection Test
          author: SAS Security Team
          severity: critical
          tags: sqli,injection
        
        requests:
          - method: GET
            path:
              - "{{BaseURL}}/api/users?id=1'"
              - "{{BaseURL}}/api/users?id=1 OR 1=1"
              - "{{BaseURL}}/api/search?q='; DROP TABLE users--"
            
            matchers:
              - type: regex
                regex:
                  - "SQL syntax.*MySQL"
                  - "Warning.*mysql_"
                  - "MySQLSyntaxErrorException"
                  - "PostgreSQL.*ERROR"
                  - "ORA-[0-9]{5}"
        EOF
        
        # XSS template
        cat > .nuclei/custom-templates/xss-test.yaml << 'EOF'
        id: xss-injection-test
        info:
          name: XSS Injection Test
          author: SAS Security Team
          severity: high
          tags: xss,injection
        
        requests:
          - method: GET
            path:
              - "{{BaseURL}}/search?q=<script>alert('XSS')</script>"
              - "{{BaseURL}}/search?q=<img src=x onerror=alert('XSS')>"
            
            matchers:
              - type: word
                words:
                  - "<script>alert('XSS')</script>"
                  - "<img src=x onerror=alert('XSS')>"
                part: body
        EOF
        
    - name: Run Nuclei Scan
      run: |
        docker run --rm -v $(pwd):/app projectdiscovery/nuclei:latest \
          -u ${{ needs.setup-environment.outputs.target_url }} \
          -t /app/.nuclei/custom-templates/ \
          -t cves/ \
          -t vulnerabilities/ \
          -t exposures/ \
          -severity critical,high,medium \
          -json -o /app/nuclei-results.json \
          -report-config /app/.nuclei/report-config.yaml \
          -stats -metrics
          
    - name: Parse Nuclei Results
      run: |
        if [ -f nuclei-results.json ]; then
          echo "## Nuclei Scan Results" > nuclei-summary.md
          echo "" >> nuclei-summary.md
          
          # Count vulnerabilities by severity
          CRITICAL=$(grep -c '"severity":"critical"' nuclei-results.json || echo 0)
          HIGH=$(grep -c '"severity":"high"' nuclei-results.json || echo 0)
          MEDIUM=$(grep -c '"severity":"medium"' nuclei-results.json || echo 0)
          
          echo "| Severity | Count |" >> nuclei-summary.md
          echo "|----------|-------|" >> nuclei-summary.md
          echo "| Critical | $CRITICAL |" >> nuclei-summary.md
          echo "| High | $HIGH |" >> nuclei-summary.md
          echo "| Medium | $MEDIUM |" >> nuclei-summary.md
          
          # Fail if critical vulnerabilities found
          if [ "$CRITICAL" -gt 0 ]; then
            echo "âŒ Critical vulnerabilities detected!" >> nuclei-summary.md
            exit 1
          fi
        fi
        
    - name: Upload Nuclei Results
      uses: actions/upload-artifact@v4
      with:
        name: nuclei-scan-results
        path: |
          nuclei-results.json
          nuclei-summary.md
        retention-days: 30

  # ===== API Security Testing =====
  api-security-test:
    name: API Security Testing
    runs-on: ubuntu-latest
    needs: setup-environment
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        
    - name: Install Test Dependencies
      run: |
        pip install requests pytest python-jose cryptography
        
    - name: JWT Security Testing
      run: |
        cat > test_jwt_security.py << 'EOF'
        import requests
        import jose
        from jose import jwt
        import json
        import sys
        
        TARGET_URL = "${{ needs.setup-environment.outputs.target_url }}"
        
        def test_jwt_none_algorithm():
            """Test for JWT None algorithm vulnerability"""
            # Get a valid token first
            response = requests.post(f"{TARGET_URL}/auth/login", json={
                "username": "test",
                "password": "test"
            })
            
            if response.status_code == 200:
                token = response.json().get("token")
                
                # Try to decode and modify
                try:
                    decoded = jwt.get_unverified_claims(token)
                    decoded["role"] = "admin"
                    
                    # Create token with none algorithm
                    malicious_token = jwt.encode(decoded, "", algorithm="none")
                    
                    # Test the malicious token
                    headers = {"Authorization": f"Bearer {malicious_token}"}
                    test_response = requests.get(f"{TARGET_URL}/api/admin", headers=headers)
                    
                    if test_response.status_code == 200:
                        print("âŒ CRITICAL: JWT None algorithm vulnerability detected!")
                        return False
                except:
                    pass
            
            print("âœ… JWT None algorithm test passed")
            return True
        
        def test_jwt_weak_secret():
            """Test for weak JWT secret"""
            common_secrets = ["secret", "password", "123456", "admin", "key"]
            
            # Get a token
            response = requests.post(f"{TARGET_URL}/auth/login", json={
                "username": "test",
                "password": "test"
            })
            
            if response.status_code == 200:
                token = response.json().get("token")
                
                for secret in common_secrets:
                    try:
                        decoded = jwt.decode(token, secret, algorithms=["HS256"])
                        print(f"âŒ CRITICAL: Weak JWT secret detected: {secret}")
                        return False
                    except:
                        continue
            
            print("âœ… JWT weak secret test passed")
            return True
        
        if __name__ == "__main__":
            results = []
            results.append(test_jwt_none_algorithm())
            results.append(test_jwt_weak_secret())
            
            if not all(results):
                sys.exit(1)
        EOF
        
        python test_jwt_security.py
        
    - name: Rate Limiting Testing
      run: |
        cat > test_rate_limiting.py << 'EOF'
        import requests
        import time
        import concurrent.futures
        import sys
        
        TARGET_URL = "${{ needs.setup-environment.outputs.target_url }}"
        
        def make_request(i):
            try:
                response = requests.get(f"{TARGET_URL}/api/users", timeout=5)
                return response.status_code
            except:
                return None
        
        def test_rate_limiting():
            """Test if rate limiting is properly implemented"""
            print("Testing rate limiting...")
            
            # Make 100 requests in parallel
            with concurrent.futures.ThreadPoolExecutor(max_workers=50) as executor:
                futures = [executor.submit(make_request, i) for i in range(100)]
                results = [f.result() for f in concurrent.futures.as_completed(futures)]
            
            # Count successful requests
            successful = results.count(200)
            rate_limited = results.count(429)
            
            print(f"Successful requests: {successful}")
            print(f"Rate limited requests: {rate_limited}")
            
            if rate_limited == 0 and successful > 50:
                print("âŒ WARNING: No rate limiting detected!")
                return False
            
            print("âœ… Rate limiting is active")
            return True
        
        if __name__ == "__main__":
            if not test_rate_limiting():
                sys.exit(1)
        EOF
        
        python test_rate_limiting.py
        
    - name: Input Validation Testing
      run: |
        cat > test_input_validation.py << 'EOF'
        import requests
        import sys
        
        TARGET_URL = "${{ needs.setup-environment.outputs.target_url }}"
        
        # Payloads for testing
        PAYLOADS = {
            "sql_injection": [
                "' OR '1'='1",
                "1; DROP TABLE users--",
                "' UNION SELECT * FROM users--"
            ],
            "xss": [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "javascript:alert('XSS')"
            ],
            "command_injection": [
                "; ls -la",
                "| whoami",
                "&& cat /etc/passwd"
            ],
            "path_traversal": [
                "../../../etc/passwd",
                "..\\..\\..\\windows\\system32\\config\\sam",
                "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd"
            ]
        }
        
        def test_input_validation():
            vulnerabilities = []
            
            for attack_type, payloads in PAYLOADS.items():
                print(f"\nTesting {attack_type}...")
                
                for payload in payloads:
                    # Test various endpoints
                    endpoints = [
                        f"/api/search?q={payload}",
                        f"/api/users?filter={payload}",
                        f"/api/data?id={payload}"
                    ]
                    
                    for endpoint in endpoints:
                        try:
                            response = requests.get(f"{TARGET_URL}{endpoint}", timeout=5)
                            
                            # Check for error disclosure
                            if any(error in response.text.lower() for error in 
                                   ["syntax error", "sql", "mysql", "postgresql", "oracle",
                                    "stack trace", "exception", "error in"]):
                                vulnerabilities.append({
                                    "type": attack_type,
                                    "endpoint": endpoint,
                                    "payload": payload
                                })
                                print(f"  âŒ Potential vulnerability: {endpoint}")
                        except:
                            pass
            
            if vulnerabilities:
                print(f"\nâŒ Found {len(vulnerabilities)} potential vulnerabilities")
                return False
            
            print("\nâœ… Input validation tests passed")
            return True
        
        if __name__ == "__main__":
            if not test_input_validation():
                sys.exit(1)
        EOF
        
        python test_input_validation.py

  # ===== Performance Security Testing =====
  performance-security-test:
    name: Performance & DoS Testing
    runs-on: ubuntu-latest
    needs: setup-environment
    if: github.event.inputs.target_environment != 'production'
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Install K6
      run: |
        sudo gpg -k
        sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg \
          --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
        echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | \
          sudo tee /etc/apt/sources.list.d/k6.list
        sudo apt-get update
        sudo apt-get install k6
        
    - name: Create K6 Security Test Script
      run: |
        cat > security-load-test.js << 'EOF'
        import http from 'k6/http';
        import { check, sleep } from 'k6';
        import { Rate } from 'k6/metrics';
        
        const errorRate = new Rate('errors');
        
        export const options = {
          stages: [
            { duration: '30s', target: 10 },  // Ramp up
            { duration: '1m', target: 50 },   // Stay at 50 users
            { duration: '30s', target: 100 }, // Spike to 100 users
            { duration: '30s', target: 0 },   // Ramp down
          ],
          thresholds: {
            http_req_duration: ['p(95)<500'], // 95% of requests under 500ms
            errors: ['rate<0.1'],              // Error rate under 10%
          },
        };
        
        const TARGET_URL = '${{ needs.setup-environment.outputs.target_url }}';
        
        export default function () {
          // Test various attack patterns
          const attacks = [
            // Large payload attack
            {
              url: `${TARGET_URL}/api/data`,
              payload: { data: 'x'.repeat(1000000) },
              method: 'POST',
            },
            // Rapid fire requests
            {
              url: `${TARGET_URL}/api/users`,
              method: 'GET',
              rapid: true,
            },
            // Deep recursion
            {
              url: `${TARGET_URL}/api/parse`,
              payload: { json: '{"a":' + '{"b":'.repeat(1000) + '1' + '}'.repeat(1000) },
              method: 'POST',
            },
          ];
          
          attacks.forEach((attack) => {
            let response;
            
            if (attack.method === 'POST') {
              response = http.post(attack.url, JSON.stringify(attack.payload), {
                headers: { 'Content-Type': 'application/json' },
                timeout: '10s',
              });
            } else {
              response = http.get(attack.url, { timeout: '10s' });
            }
            
            const success = check(response, {
              'status is not 5xx': (r) => r.status < 500,
              'response time OK': (r) => r.timings.duration < 500,
            });
            
            errorRate.add(!success);
            
            if (!attack.rapid) {
              sleep(1);
            }
          });
        }
        EOF
        
    - name: Run K6 Security Load Test
      run: |
        k6 run --out json=k6-results.json security-load-test.js || true
        
    - name: Analyze K6 Results
      run: |
        if [ -f k6-results.json ]; then
          python3 << 'EOF'
        import json
        import sys
        
        with open('k6-results.json', 'r') as f:
            lines = f.readlines()
        
        metrics = {
            'errors': 0,
            'duration_p95': 0,
            'requests': 0
        }
        
        for line in lines:
            try:
                data = json.loads(line)
                if data.get('type') == 'Point':
                    metric = data.get('metric')
                    if metric == 'errors':
                        metrics['errors'] += 1
                    elif metric == 'http_req_duration':
                        metrics['duration_p95'] = max(metrics['duration_p95'], data['data']['value'])
                    elif metric == 'http_reqs':
                        metrics['requests'] += 1
            except:
                pass
        
        print(f"Total Requests: {metrics['requests']}")
        print(f"Errors: {metrics['errors']}")
        print(f"P95 Duration: {metrics['duration_p95']}ms")
        
        # Check thresholds
        if metrics['errors'] > metrics['requests'] * 0.1:
            print("âŒ Error rate too high!")
            sys.exit(1)
        
        if metrics['duration_p95'] > 500:
            print("âŒ Performance degradation detected!")
            sys.exit(1)
        
        print("âœ… Performance security test passed")
        EOF
        fi
        
    - name: Upload Performance Results
      uses: actions/upload-artifact@v4
      with:
        name: performance-security-results
        path: |
          k6-results.json
          security-load-test.js
        retention-days: 30

  # ===== Container Security Testing =====
  container-runtime-security:
    name: Container Runtime Security
    runs-on: ubuntu-latest
    if: github.event.inputs.target_environment == 'staging'
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      
    - name: Install Falco
      run: |
        curl -s https://falco.org/repo/falcosecurity-3672BA8F.asc | apt-key add -
        echo "deb https://download.falco.org/packages/deb stable main" | \
          tee -a /etc/apt/sources.list.d/falcosecurity.list
        apt-get update -y
        apt-get install -y falco
        
    - name: Configure Falco Rules
      run: |
        cat > falco-rules.yaml << 'EOF'
        - rule: Unauthorized Process
          desc: Detect unauthorized process execution
          condition: >
            spawned_process and
            not proc.name in (allowed_processes)
          output: >
            Unauthorized process started
            (user=%user.name command=%proc.cmdline container=%container.id)
          priority: WARNING
          
        - rule: Sensitive File Access
          desc: Detect access to sensitive files
          condition: >
            open_read and
            fd.name in (/etc/shadow, /etc/passwd, /root/.ssh/*)
          output: >
            Sensitive file accessed
            (user=%user.name file=%fd.name container=%container.id)
          priority: WARNING
        EOF
        
    - name: Run Runtime Security Scan
      run: |
        # Start Falco in background
        falco -r falco-rules.yaml -o json_output=true > falco-output.json &
        FALCO_PID=$!
        
        # Wait for monitoring period
        sleep 300
        
        # Stop Falco
        kill $FALCO_PID
        
        # Analyze results
        if [ -f falco-output.json ]; then
          WARNINGS=$(grep -c "WARNING" falco-output.json || echo 0)
          ERRORS=$(grep -c "ERROR" falco-output.json || echo 0)
          
          echo "Runtime Security Scan Results:"
          echo "Warnings: $WARNINGS"
          echo "Errors: $ERRORS"
          
          if [ "$ERRORS" -gt 0 ]; then
            echo "âŒ Critical runtime security issues detected!"
            exit 1
          fi
        fi

  # ===== DAST Report Generation =====
  generate-dast-report:
    name: Generate DAST Report
    runs-on: ubuntu-latest
    needs: [owasp-zap-scan, nuclei-scan, api-security-test]
    if: always()
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Download All DAST Artifacts
      uses: actions/download-artifact@v4
      with:
        path: dast-artifacts
        
    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        
    - name: Install Dependencies
      run: |
        pip install jinja2 markdown beautifulsoup4
        
    - name: Generate Consolidated DAST Report
      run: |
        cat > generate_dast_report.py << 'EOF'
        import json
        import os
        from datetime import datetime
        from pathlib import Path
        
        def generate_dast_summary():
            report = {
                "timestamp": datetime.now().isoformat(),
                "scan_type": "DAST",
                "target": "${{ needs.setup-environment.outputs.target_url }}",
                "tools_executed": [],
                "vulnerabilities": {
                    "critical": 0,
                    "high": 0,
                    "medium": 0,
                    "low": 0
                },
                "findings": []
            }
            
            # Process ZAP results
            zap_report = Path("dast-artifacts/zap-scan-results/zap_full_report.html")
            if zap_report.exists():
                report["tools_executed"].append("OWASP ZAP")
                # Parse ZAP HTML report for vulnerabilities
                
            # Process Nuclei results
            nuclei_report = Path("dast-artifacts/nuclei-scan-results/nuclei-results.json")
            if nuclei_report.exists():
                report["tools_executed"].append("Nuclei")
                with open(nuclei_report, 'r') as f:
                    for line in f:
                        try:
                            finding = json.loads(line)
                            severity = finding.get("info", {}).get("severity", "low")
                            report["vulnerabilities"][severity] += 1
                            report["findings"].append({
                                "tool": "Nuclei",
                                "type": finding.get("template-id"),
                                "severity": severity,
                                "url": finding.get("matched-at"),
                                "details": finding.get("info", {}).get("name")
                            })
                        except:
                            pass
            
            # Generate HTML report
            html_template = """
            <!DOCTYPE html>
            <html>
            <head>
                <title>DAST Security Report</title>
                <style>
                    body { font-family: Arial, sans-serif; margin: 40px; }
                    .header { background: #1a73e8; color: white; padding: 20px; }
                    .summary { background: #f8f9fa; padding: 20px; margin: 20px 0; }
                    .critical { color: #dc3545; }
                    .high { color: #fd7e14; }
                    .medium { color: #ffc107; }
                    .low { color: #28a745; }
                    table { width: 100%; border-collapse: collapse; margin: 20px 0; }
                    th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
                    th { background: #f2f2f2; }
                </style>
            </head>
            <body>
                <div class="header">
                    <h1>DAST Security Assessment Report</h1>
                    <p>Target: {{ target }}</p>
                    <p>Date: {{ date }}</p>
                </div>
                
                <div class="summary">
                    <h2>Executive Summary</h2>
                    <table>
                        <tr>
                            <th>Severity</th>
                            <th>Count</th>
                        </tr>
                        <tr>
                            <td class="critical">Critical</td>
                            <td>{{ vulnerabilities.critical }}</td>
                        </tr>
                        <tr>
                            <td class="high">High</td>
                            <td>{{ vulnerabilities.high }}</td>
                        </tr>
                        <tr>
                            <td class="medium">Medium</td>
                            <td>{{ vulnerabilities.medium }}</td>
                        </tr>
                        <tr>
                            <td class="low">Low</td>
                            <td>{{ vulnerabilities.low }}</td>
                        </tr>
                    </table>
                </div>
                
                <h2>Detailed Findings</h2>
                <table>
                    <tr>
                        <th>Tool</th>
                        <th>Finding</th>
                        <th>Severity</th>
                        <th>URL</th>
                    </tr>
                    {% for finding in findings %}
                    <tr>
                        <td>{{ finding.tool }}</td>
                        <td>{{ finding.details }}</td>
                        <td class="{{ finding.severity }}">{{ finding.severity|upper }}</td>
                        <td>{{ finding.url }}</td>
                    </tr>
                    {% endfor %}
                </table>
            </body>
            </html>
            """
            
            from jinja2 import Template
            template = Template(html_template)
            html_report = template.render(
                target=report["target"],
                date=report["timestamp"],
                vulnerabilities=report["vulnerabilities"],
                findings=report["findings"]
            )
            
            with open("dast-report.html", "w") as f:
                f.write(html_report)
            
            with open("dast-summary.json", "w") as f:
                json.dump(report, f, indent=2)
            
            # Check thresholds
            if report["vulnerabilities"]["critical"] > 0:
                print(f"âŒ {report['vulnerabilities']['critical']} critical vulnerabilities found!")
                return False
            
            if report["vulnerabilities"]["high"] > 3:
                print(f"âš ï¸ {report['vulnerabilities']['high']} high vulnerabilities found!")
            
            return True
        
        if __name__ == "__main__":
            import sys
            if not generate_dast_summary():
                sys.exit(1)
        EOF
        
        python generate_dast_report.py
        
    - name: Upload DAST Report
      uses: actions/upload-artifact@v4
      with:
        name: dast-report
        path: |
          dast-report.html
          dast-summary.json
        retention-days: 90
        
    - name: Create Issue for Critical Findings
      if: failure()
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const summary = JSON.parse(fs.readFileSync('dast-summary.json', 'utf8'));
          
          if (summary.vulnerabilities.critical > 0) {
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸš¨ Critical Security Vulnerabilities Detected - DAST Scan`,
              body: `## Critical Security Alert
              
              The DAST scan has detected **${summary.vulnerabilities.critical}** critical vulnerabilities.
              
              ### Summary
              - **Target**: ${summary.target}
              - **Scan Date**: ${summary.timestamp}
              - **Critical**: ${summary.vulnerabilities.critical}
              - **High**: ${summary.vulnerabilities.high}
              - **Medium**: ${summary.vulnerabilities.medium}
              - **Low**: ${summary.vulnerabilities.low}
              
              ### Action Required
              1. Review the detailed DAST report
              2. Prioritize and fix critical vulnerabilities immediately
              3. Re-run DAST scan after fixes
              
              [View Full Report](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})
              
              cc: @security-team`,
              labels: ['security', 'critical', 'dast']
            });
          }