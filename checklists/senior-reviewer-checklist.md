# Senior Reviewer チェックリスト

**エス・エー・エス株式会社**  
*経験者・上級レビュアー向けチェックリスト*

## 🎯 概要

このチェックリストは、経験豊富なレビュアー向けに、より深い技術的洞察とビジネス影響を考慮したレビューを行うためのガイドラインです。

## 🏗️ アーキテクチャ・設計レビュー

### システム設計の評価
```markdown
## 設計原則の適用
- [ ] **SOLID原則**
  - [ ] Single Responsibility: 各クラス/モジュールが単一の責任を持つ
  - [ ] Open/Closed: 拡張に開かれ、修正に閉じている
  - [ ] Liskov Substitution: 派生クラスが基底クラスと置換可能
  - [ ] Interface Segregation: インターフェースが適切に分離されている
  - [ ] Dependency Inversion: 抽象に依存し、具象に依存しない

- [ ] **DRY (Don't Repeat Yourself)**
  - [ ] コードの重複が最小限
  - [ ] 共通ロジックの適切な抽出
  - [ ] 過度な抽象化を避けている

- [ ] **KISS (Keep It Simple, Stupid)**
  - [ ] 不必要な複雑性がない
  - [ ] シンプルで理解しやすい実装
```

### デザインパターンの適用
```markdown
## パターン評価
- [ ] 適切なデザインパターンの選択
  - [ ] Singleton: 本当に単一インスタンスが必要か
  - [ ] Factory: オブジェクト生成の複雑性が適切に隠蔽されているか
  - [ ] Observer: イベント駆動が適切か
  - [ ] Strategy: アルゴリズムの切り替えが柔軟か

- [ ] アンチパターンの回避
  - [ ] God Object/Class の不在
  - [ ] Spaghetti Code の回避
  - [ ] Copy-Paste Programming の防止
```

### スケーラビリティ評価
```markdown
## スケーラビリティ考慮事項
- [ ] **水平スケーリング対応**
  - [ ] ステートレス設計
  - [ ] セッション管理の外部化
  - [ ] 分散処理への対応

- [ ] **垂直スケーリング考慮**
  - [ ] リソース使用の最適化
  - [ ] メモリ効率の良い実装

- [ ] **データベース設計**
  - [ ] 適切なインデックス設計
  - [ ] シャーディング戦略
  - [ ] 読み書き分離の考慮
```

## ⚡ パフォーマンス最適化レビュー

### アルゴリズム分析
```markdown
## 計算量評価
- [ ] **時間計算量**
  - [ ] O(n²)以上の処理の妥当性確認
  - [ ] ループのネストの最小化
  - [ ] 早期リターンの活用

- [ ] **空間計算量**
  - [ ] メモリ使用量の適切性
  - [ ] 不要なオブジェクト生成の回避
  - [ ] メモリリークの可能性チェック

- [ ] **アルゴリズム選択**
  - [ ] データ構造の適切な選択（Array vs Set vs Map）
  - [ ] ソートアルゴリズムの適切性
  - [ ] 検索アルゴリズムの効率性
```

### データベース最適化
```markdown
## クエリ最適化
- [ ] **N+1問題の防止**
  ```ruby
  # ❌ 悪い例
  users.each do |user|
    user.posts.count  # N+1クエリ
  end

  # ✅ 良い例
  users.includes(:posts).each do |user|
    user.posts.size  # eager loading
  end
  ```

- [ ] **インデックス戦略**
  - [ ] 頻繁に検索される列のインデックス
  - [ ] 複合インデックスの順序
  - [ ] 過度なインデックスの回避

- [ ] **クエリ効率**
  - [ ] SELECT * の回避
  - [ ] 適切なJOIN戦略
  - [ ] サブクエリ vs JOIN の選択
```

### キャッシング戦略
```markdown
## キャッシュ実装
- [ ] **キャッシュレベル**
  - [ ] アプリケーションレベルキャッシュ
  - [ ] データベースクエリキャッシュ
  - [ ] CDN/ブラウザキャッシュ

- [ ] **キャッシュ無効化**
  - [ ] TTL設定の適切性
  - [ ] キャッシュクリア戦略
  - [ ] キャッシュスタンピード対策

- [ ] **キャッシュ一貫性**
  - [ ] データ整合性の保証
  - [ ] 分散キャッシュの同期
```

## 🔒 高度なセキュリティレビュー

### 認証・認可の実装
```markdown
## 認証メカニズム
- [ ] **認証フロー**
  - [ ] OAuth2.0/OpenID Connect の正しい実装
  - [ ] JWT の安全な実装（署名検証、有効期限）
  - [ ] セッション管理の安全性

- [ ] **多要素認証（MFA）**
  - [ ] TOTP/SMS/生体認証の実装
  - [ ] バックアップコードの管理
  - [ ] リカバリーフローの安全性

- [ ] **認可制御**
  - [ ] RBAC/ABAC の適切な実装
  - [ ] 最小権限の原則
  - [ ] 権限昇格の防止
```

### 暗号化とデータ保護
```markdown
## 暗号化実装
- [ ] **暗号化アルゴリズム**
  - [ ] 推奨アルゴリズムの使用（AES-256等）
  - [ ] 適切な暗号化モード（GCM推奨）
  - [ ] 安全な乱数生成

- [ ] **鍵管理**
  - [ ] HSM/KMS の活用
  - [ ] 鍵のローテーション戦略
  - [ ] 鍵の安全な保管

- [ ] **データ保護**
  - [ ] PII の適切な処理
  - [ ] データマスキング/トークナイゼーション
  - [ ] 安全な削除（データの完全消去）
```

## 🧪 高度なテスト戦略

### テスト設計評価
```markdown
## テスト戦略
- [ ] **テストピラミッド**
  - [ ] 単体テスト（70%）
  - [ ] 統合テスト（20%）
  - [ ] E2Eテスト（10%）

- [ ] **テスト品質**
  - [ ] テストの独立性（順序依存なし）
  - [ ] テストの決定性（flaky test なし）
  - [ ] テストの速度（実行時間の最適化）

- [ ] **特殊なテスト**
  - [ ] 性能テスト
  - [ ] セキュリティテスト
  - [ ] カオスエンジニアリング
```

### モックとスタブの適切性
```markdown
## Mock/Stub戦略
- [ ] **適切な使用**
  ```javascript
  // ✅ 良い例：外部依存のモック
  jest.mock('./emailService');
  
  // ❌ 悪い例：ビジネスロジックのモック
  jest.mock('./calculatePrice'); // ビジネスロジックは実際にテスト
  ```

- [ ] **テストダブルの選択**
  - [ ] Dummy: 使われないパラメータ
  - [ ] Stub: 固定値を返す
  - [ ] Spy: 呼び出しを記録
  - [ ] Mock: 期待値を検証
  - [ ] Fake: 簡易実装
```

## 💼 ビジネス影響分析

### 機能影響評価
```markdown
## ビジネスインパクト
- [ ] **ユーザー影響**
  - [ ] 影響を受けるユーザー数
  - [ ] ユーザー体験への影響度
  - [ ] ダウンタイムの可能性

- [ ] **収益影響**
  - [ ] 直接的な収益への影響
  - [ ] 間接的なビジネス価値
  - [ ] 機会損失のリスク

- [ ] **コンプライアンス**
  - [ ] 規制要件の充足
  - [ ] SLA への影響
  - [ ] 監査要件の考慮
```

### リスク評価
```markdown
## リスク分析
- [ ] **技術的リスク**
  - [ ] 実装の複雑性
  - [ ] 依存関係の変更
  - [ ] 既存システムへの影響

- [ ] **運用リスク**
  - [ ] デプロイメントリスク
  - [ ] ロールバック可能性
  - [ ] 監視・アラート設定

- [ ] **セキュリティリスク**
  - [ ] 新たな攻撃面
  - [ ] データ漏洩リスク
  - [ ] コンプライアンス違反
```

## 📊 メトリクスとモニタリング

### 観測可能性の実装
```markdown
## Observability
- [ ] **ログ戦略**
  - [ ] 構造化ログの実装
  - [ ] 適切なログレベル
  - [ ] ログ集約の考慮

- [ ] **メトリクス**
  - [ ] ビジネスメトリクス
  - [ ] 技術メトリクス
  - [ ] カスタムメトリクス

- [ ] **トレーシング**
  - [ ] 分散トレーシング
  - [ ] リクエストID の伝播
  - [ ] パフォーマンスプロファイリング

- [ ] **アラート設定**
  - [ ] 閾値の適切性
  - [ ] アラート疲れの防止
  - [ ] エスカレーション設定
```

## 🔄 技術的負債の管理

### 負債の識別と評価
```markdown
## 技術的負債
- [ ] **負債の種類**
  - [ ] 設計負債
  - [ ] コード負債
  - [ ] テスト負債
  - [ ] ドキュメント負債

- [ ] **負債の影響**
  - [ ] 開発速度への影響
  - [ ] 保守コストの増加
  - [ ] バグ発生リスク

- [ ] **返済計画**
  - [ ] 優先度付け
  - [ ] 段階的な改善
  - [ ] リファクタリング戦略
```

## 🎓 メンタリングとナレッジシェア

### コードレビューを通じた教育
```markdown
## 教育的フィードバック
- [ ] **建設的な提案**
  ```markdown
  // 良いフィードバック例
  "このロジックは Strategy パターンを使うことで、
  将来の拡張が容易になります。以下のリファクタリングを
  提案します：[具体的なコード例]
  参考: [デザインパターンのリンク]"
  ```

- [ ] **ベストプラクティスの共有**
  - [ ] 社内標準への言及
  - [ ] 業界標準の紹介
  - [ ] 具体的な改善例の提示

- [ ] **成長機会の提供**
  - [ ] チャレンジングな課題の設定
  - [ ] ペアプログラミングの提案
  - [ ] 追加学習リソースの紹介
```

## 📋 Senior Reviewer クイックチェックリスト

```markdown
## アーキテクチャ
- [ ] SOLID原則準拠
- [ ] 適切なデザインパターン
- [ ] スケーラビリティ考慮

## パフォーマンス
- [ ] アルゴリズム効率
- [ ] データベース最適化
- [ ] キャッシュ戦略

## セキュリティ
- [ ] 認証・認可の適切性
- [ ] 暗号化実装
- [ ] 脆弱性対策

## ビジネス
- [ ] ユーザー影響評価
- [ ] リスク分析
- [ ] ROI考慮

## 品質
- [ ] テスト戦略
- [ ] 観測可能性
- [ ] 技術的負債管理

## チーム
- [ ] ナレッジシェア
- [ ] ドキュメント更新
- [ ] メンタリング機会
```

## 🚀 次のステップ

Senior Reviewer として、以下の責任を持ちます：
1. **技術的リーダーシップ**: アーキテクチャ決定の指導
2. **品質の守護者**: 高い品質基準の維持
3. **メンター**: Junior/Mid-level エンジニアの成長支援
4. **イノベーター**: 新技術・手法の導入提案

---

**注意**: このチェックリストは包括的ですが、すべての項目を毎回確認する必要はありません。PRの性質と重要度に応じて適切な項目を選択してください。